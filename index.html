<!DOCTYPE html>
<html>
<head>
    <title>Mahjong Solitaire</title>
    <style>
        .board {
            width: 700px;
            height: 600px;
            margin: 20px auto;
            position: relative;
        }
        
        .tile {
            width: 80px;
            height: 100px;
            background: #f0f0f0;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 24px;
            position: absolute;
            transition: opacity 0.3s;
        }
        
        .tile.selected {
            background: #ffff99;
        }
        
        .tile.matched {
            opacity: 0;
            pointer-events: none;
        }
        
        .tile.blocked {
            background: #d0d0d0;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="gameBoard" class="board"></div>
    <div style="text-align: center;">
        <button onclick="resetGame()">Reset Game</button>
    </div>

    <script>
        // Tile types (18 unique symbols, each appearing twice)
        const tileTypes = [
            'ðŸ‰', 'ðŸŽ', 'ðŸ’®', 'ðŸŒ¸', 'ðŸŽ‹', 'ðŸ‚',
            'ðŸ€„', 'ðŸŒŸ', 'â˜¯ï¸', 'ðŸƒ', 'ðŸŒ¹', 'ðŸ…',
            'â›°ï¸', 'ðŸŒŠ', 'â˜€ï¸', 'ðŸŒ™', 'ðŸ', 'ðŸŽ'
        ];

        class MahjongGame {
            constructor() {
                this.tiles = [];
                this.selectedTile = null;
                this.initializeBoard();
            }

            // Define a simple pyramid-like layered layout
            initializeBoard() {
                const layout = [
                    // Layer 0 (bottom): 8 tiles
                    { x: 1, y: 4, z: 0 }, { x: 2, y: 4, z: 0 }, { x: 3, y: 4, z: 0 }, { x: 4, y: 4, z: 0 },
                    { x: 5, y: 4, z: 0 }, { x: 6, y: 4, z: 0 }, { x: 7, y: 4, z: 0 }, { x: 8, y: 4, z: 0 },
                    // Layer 0 sides
                    { x: 0, y: 3, z: 0 }, { x: 9, y: 3, z: 0 },
                    // Layer 1: 6 tiles
                    { x: 2, y: 3, z: 1 }, { x: 3, y: 3, z: 1 }, { x: 4, y: 3, z: 1 },
                    { x: 5, y: 3, z: 1 }, { x: 6, y: 3, z: 1 }, { x: 7, y: 3, z: 1 },
                    // Layer 2: 4 tiles
                    { x: 3, y: 2, z: 2 }, { x: 4, y: 2, z: 2 }, { x: 5, y: 2, z: 2 }, { x: 6, y: 2, z: 2 },
                    // Layer 3: 2 tiles
                    { x: 4, y: 1, z: 3 }, { x: 5, y: 1, z: 3 },
                    // Layer 4 (top): 1 tile
                    { x: 4.5, y: 0, z: 4 }
                ];

                // Prepare tiles (use only as many pairs as layout positions: 21 tiles = 10 pairs + 1 extra)
                const selectedTypes = tileTypes.slice(0, 11); // 11 unique tiles
                let gameTiles = [...selectedTypes, ...selectedTypes.slice(0, 10)]; // 21 tiles (10 pairs + 1)

                // Shuffle tiles
                for (let i = gameTiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [gameTiles[i], gameTiles[j]] = [gameTiles[j], gameTiles[i]];
                }

                // Create tile elements
                const board = document.getElementById('gameBoard');
                board.innerHTML = '';
                this.tiles = [];

                gameTiles.forEach((symbol, index) => {
                    const pos = layout[index];
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.textContent = symbol;
                    tile.dataset.index = index;
                    tile.style.left = `${pos.x * 70}px`; // Adjusted spacing
                    tile.style.top = `${pos.y * 90}px`;
                    tile.style.zIndex = pos.z * 10;
                    tile.addEventListener('click', () => this.handleTileClick(tile));
                    board.appendChild(tile);
                    this.tiles.push({
                        element: tile,
                        symbol: symbol,
                        matched: false,
                        x: pos.x,
                        y: pos.y,
                        z: pos.z
                    });
                });

                this.updateTileStates();
            }

            // Check if a tile is free (no tiles to its left/right AND no tile above)
            isTileFree(tile) {
                const leftBlocked = this.tiles.some(t => 
                    !t.matched && t.z === tile.z && t.x === tile.x - 1 && t.y === tile.y
                );
                const rightBlocked = this.tiles.some(t => 
                    !t.matched && t.z === tile.z && t.x === tile.x + 1 && t.y === tile.y
                );
                const aboveBlocked = this.tiles.some(t => 
                    !t.matched && t.z > tile.z && t.x >= tile.x - 0.5 && t.x <= tile.x + 0.5 && t.y <= tile.y
                );

                return !leftBlocked && !rightBlocked && !aboveBlocked;
            }

            // Update which tiles are clickable
            updateTileStates() {
                this.tiles.forEach(tile => {
                    if (!tile.matched) {
                        if (this.isTileFree(tile)) {
                            tile.element.classList.remove('blocked');
                        } else {
                            tile.element.classList.add('blocked');
                        }
                    }
                });
            }

            handleTileClick(tile) {
                const index = parseInt(tile.dataset.index);
                const currentTile = this.tiles[index];

                if (currentTile.matched || !this.isTileFree(currentTile) || tile === this.selectedTile) return;

                if (!this.selectedTile) {
                    // First tile selected
                    this.selectedTile = tile;
                    tile.classList.add('selected');
                } else {
                    // Second tile selected
                    const firstTile = this.tiles[this.selectedTile.dataset.index];
                    const secondTile = currentTile;

                    if (firstTile.symbol === secondTile.symbol) {
                        // Match found
                        firstTile.element.classList.add('matched');
                        secondTile.element.classList.add('matched');
                        firstTile.matched = true;
                        secondTile.matched = true;
                        
                        this.updateTileStates();
                        this.checkWin();
                    }

                    // Reset selection
                    this.selectedTile.classList.remove('selected');
                    this.selectedTile = null;
                    tile.classList.remove('selected');
                }
            }

            checkWin() {
                if (this.tiles.every(tile => tile.matched)) {
                    setTimeout(() => alert('Congratulations! You won!'), 500);
                }
            }
        }

        let game;
        
        function startGame() {
            game = new MahjongGame();
        }

        function resetGame() {
            startGame();
        }

        // Start the game when page loads
        window.onload = startGame;
    </script>
</body>
</html>
